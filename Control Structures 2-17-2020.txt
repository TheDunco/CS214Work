<https://cs.calvin.edu/courses/cs/214/adams/pdfs/N02.ControlStructures-Color.pdf />

In the early 60's, <spaghetti coding> was a common practice, whether using a HLL or a formal model like the RAM.
In assembly, you only have conditional and unconditional jumps, so these early languages were reflections of that

double f(double n) {
double x = y = 1.0;
if (n < 2.0) goto label2;
label1: if (x > n) goto label2;
y *= x;
x++;
goto label1;
label2: return y;
}


The <structure> does not indicate <the flow of control>
Such code was <expensive to maintain...>

in '68, Dijkstra published "Goto Considered Harmful"
-- suggested the <goto> shoudl be outlawed because it encouraged <undisciplined coding>

Language designers began building <control structures>
-- statements whose syntax mad control-flow obvious

- If 	FORTRAN		-If-Then-Else		COBOL
- Case	Algol-W		-If-Then-Elseif		Algol-68
- For	Algol-60	-While				Pascal
-Do		COBOL

With Pascal (1970), all of these were available in 1 language, resulting in a new coding style: <structured programming>
Think of it like the Second generation in terms of programming style

---day2---

Structured programming emphasizes <readability> through:
- Use of appropriate contorl structures
- Use of descriptive identifiers
- Use of white space (indentation, blank lines)

ex. 
double factorial(double n)
{
	double result = 1.0;
	for (int count = 2; count <= n; count++)
		result *= count;
	return result;
}

With structured programming, <flow of control is clear!> 
The resulting programs were <less expensive to maintain.>

A C/C++ block has <0 or more> statements:

<block-stmt> ::= { <stmt-list> }
<stmt-list> ::= <stmt> <stmt-list> | ε


An Ada block statement has <1 or more> stmts:

<block-stmt> ::= begin <stmt-list> end
<stmt-list> ::= <stmt> <more-stmts>

<more-stmts> ::= <stmt> <more-stmts> | ε
The semicolons are used as statement terminators in Ada (as seen in slides)

The block is the control structure for <sequential execution>, 
the default control structure in inperative languages.

The guiding principle for all control structures is <One entry point, one exit point> 
(denoted by arrows in <slides>)

Smalltalk also has a <block> consruct, but it is an <object>
"." seperates expressions in the block

<block-object> ::= [ <params> <locals> <expr-list> ]
<params> ::= <param-list> ‘|’ | ε
<param-list> ::= : id <param-list> | ε
<locals> ::= ‘|’ <id-list> ‘|’ | ε
<id-list> ::= id <id-list> | ε
<expr-list> ::= <expr> <more-exprs> | ε
<more-exprs> ::= . <expr> <more-exprs> | ε

[2 + 1] value            → 3

Like C/C++, a Smalltalk block can declare local variables;
but as an object, a Smalltalk block can also have <parameters>:

[:i | i + 1] value: 2     → 3

| aBlock | aBlock := [:x :y | (x*x) + (y*y) ] . aBlock value: 3 value: 4 → 25


The expressions in the “body” of a Lisp function are executed
sequentially, by default, with the value of the function being
the value of <the last (final) expression in the sequence:

(defun summation (n)
	(setq t1 (+ n 1))
	(setq t2 (* n t1))
	(setq t3 (/ t2 2)))
	)))
summation (summation 100)  -> 5050

Of course, summation() can be written more succinctly:
(defun summation (n) 
	(/ (* (+ n 1) n) 2)
))

Some Lisp function-arguments must be a single expression.
Lisp’s <progn> function can be used to execute several
expressions sequentially, much like other languages’ <block>:

(defun summation (n)
	(if (<= n 0)
	(progn
		(message "summation(n): n must be positive...")
		0)
	(/ (* (+ n 1) n) 2)))
	
	"
The progn function returns the value of its <final expression>.
Lisp also has sequential prog1 and prog2 functions, that
return the values of the 1st and 2nd expressions, respectively.



Selective execution lets us <select/execute one statment and ignore another>

The If Statement

<if-statement> ::= if ( <expr> ) <stmt> <else-part>
<else-part> ::= else <stmt> | ε

<see slides for flow control>


Examples

These three forms allow us to use selective execution in
whatever manner is appropriate to solve a given problem


<Single-Branch Logic>:
if (numValues != 0)
	avg = sum / numValues;

<Dual-Branch Logic>:
if (first < second)
	min = first;
else
	min = second;

<Multi-Branch Logic>:
if (score > 89)
	grade = 'A';
else if (score > 79)
	grade = 'B';
else if (score > 69)
	grade = 'C';
else if (score > 59)
	grade = 'D';
else
	grade = 'F';


The Dangling Else Problem
Every language designer must resolve the question of how to
associate a “dangling else” following nested if statements...
<see slides for explanation/graphic>

The problem occurs in languages with <ambiguous grammars>.
→ Such a statement can be <parsed> in two different ways.

There are two different approaches to resolving the question:
•Add a *semantic rule* to resolve the ambiguity; vs.
•Design a statement whose syntax is not ambiguous.


Using Semantics
Languages from the 1970s (Pascal, C) tended to use simple
but ambiguous grammars:
<if-stmt> ::= if ( <expr> ) <stmt> <else-part>
<else-part> ::= else <stmt> | ε

Plus a semantic rule:
<An else always associates witht he nearest unterminated if>
<slides for more info>

Block statments provided a way to circumvent the rule. 
Newer C-family languages (C++, Java) have inherited this


Using Syntax
Newer languages tend to use <syntax that is unambiguous>
<if-stmt> ::= if ( <expr> ) <stmt-list> <else-part> end if
<else-part> ::= else <stmt-list> | ε
<stmt-list> ::= <stmt> <stmt-list> | ε

Terminating an if with an end if “closes” the most recent
else, eliminating the ambiguity without any semantic rules:


Perl uses a (different) syntax solution:
<if-stmt> ::= if ( <expr> ) <block> <else-part>
<else-part> ::= else <block> | ε
<block> ::= { <stmt-list> }

By requiring each branch of an if to be a block, <any nested if is "enclosed" in a block,> eliminating the ambiguity: 
The nested block serves to terminate the nested if

Always putting the bracket after a C++ if will basically use this approach, even if you only have one statment

if {
} else {
}


Aesthetics <see slides for sure>

To avoid this problem, Algol-68 added the elif keyword that substituted for else if, <extends the same if statement.>

Modula-2 and Ada replaced the error-prone elif keyword with elsif

-----'nother day----

<Ada-if-stmt> ::= if <condition> then <stmt_list> <elsif_part> <opt_else-part> end if; (can exclude semicolon so every statment doesn't have to supply it)
<elsif_part> ::= elsif <condition> then <stmt_list> <elsif_part> | ε
<opt_else-part> ::= else <stmt_list> | ε


Lisp’s 	if
Lisp provides an <if function> as one if its expressions

It is not unusual for a Lisp
expression to end with ))))

Lost In Silly Parentheses {[INSTALL RAINBOW MODE]}

Selection in Smalltalk
Smalltalk provides various <if True: and ifFalse: messages> that can be sent to <boolean objects>...

<on board>
Boolean Object 	if True: [block 1]
True or False	if False: [block 2]

<definately look at example on slides>
Only four selection messages Smalltalk provides


Problem: Non-Uniform execution

The times to execute different branches are <different?>:
•The 1st <stmt> executes after 1 comparison.
•The nth and final <stmt> execute after <1> comparisons.
The time to execute successive branches increases <linearly>.


The Switch Statement

The switch statement provides <uniform-time multibranching>.

Note: If you neglect to supply
break statements, control by
default flows <sequentially>
through the switch statement.
The break is a <restricted-goto> statement...

Uniform Execution time
Compiled switch/case statements achieve uniform response
time via a <jump table>, that stores the address of each branch.
Simplified but gives the general idea

<slides for assembly code>

For non-default branches, a
switch/case needs <2 compares (comp)>
and <1 move (mov)> to find the branch. <(Never changes even if you have 100+ statments)>
When a multibranch if does <three or more comparisons>,
a switch is probably faster.
A compiler spends <compile> time and space (to build the
jump table) to decrease the
average <run-time> time needed to
find a branch.

The Case Statement

The switch is a descendent of the <case> statment (Algol-W).
Only <C-family> languages use the switch syntax.

Unlike the switch, a case
statement <does not have drop-through> behavior.
Most case stmts also let you use
literal <lists> and <ranges>:

BNF for Ada's case stmt.

<Ada-case> ::= case <int-compatible-expression> of <when-clauses> <others-clause> end case; (again, semicolon optional)
<when-clauses> ::= <when-clause> <more-clauses>
<when-clause> ::= when <literals> => <stmt_list>
<more-clauses> ::= <when-clause> <more-clauses> | ε
<literals> ::= <literal-list> | <literal-range>
<literal-list> ::= <literal> <more-literals>
<more-literals> ::= , <literal> <more-literals> | ε
<literal-range> ::= <literal> .. <literal>
<others-clause> ::= when others => <stmt_list> | ε

Lisp provices a <cond> function that looks similar to a <case>.
<see slides for example and stuff>
The predicates are evaluated <sequentially> until a true
<predicate> is found; its <expr> is then evaluated.

Repetition
A third control structure is <repetition,> or looping. 

The C++ <while> loop is a <pretest> or <test-at-the-top> loop:
<while-stmt> ::= while ( <expr> ) <stmt>

but the <do> loop is a <posttest> or <test-at-the-bottom> loop:
<do-stmt> ::= do <stmt> while ( <expr> ) 

<look at slides to clarify flow> 

A pretest loop’s <stmt> is executed <0+> times (<zero trip behavior>).
A posttest loop's <stmt> is executed <1+> (<one trip behavior>).


Counting Loops

Like most languages, C++ provides a <for> loop for counting:
This provides unusual flexibility for an imperative language:
<for-stmt> ::= for ( <opt-expr> ; <opt-expr> ; <opt-expr> ) <stmt> 

This provides unusual flexibility for an imperative language: <see slides for examples>

In most languages, the counting loop is a <pretest> loop.


Unrestricted Loops

Most modern languages also support an <unrestricted>.
-Such loops have <no fixed exit point>.
-All of the C/C++ loops can be made to behave this way:
for (;;)	while (true)	do
<stmt>		<stmt>			<stmt>
							while (true);

−The language usually provides a statement to exit such loops.
−Unrestricted loops can be structured as <test-at-the-top>, <test-at-the-bottom>, or <test-in-the-middle> loops:

- <stmt>1 executes <___> times;
- <stmt>2 executes ____ times...


Ada
Ada provides ________, ________, and ___________ loops:

Exercise: How would you build a BNF for Ada’s loops?

<Ada-loop-stmt>::= _____________________________________________
___________ ::= ___________________________________________
____________ ::= _________________________
___________ ::= ____________________________________
____________ ::= ______________________________________________
___________ ::= _______________________________
What if you need a post-test loop, or to count by i != 1?












