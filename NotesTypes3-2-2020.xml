<https://cs.calvin.edu/courses/cs/214/adams/pdfs/N03.Types-I-Color.pdf>

Types:{ 
    A <type> is a <set V of values, and a set O of operations onto V.>

    Ex. C++
    •The <int> type:
    V = {INT_MIN, ... -1, 0, 1, ..., INT_MAX-1, INT_MAX}
    O = {<<, >>, +, -, *, /, %, =, ++, --, ...}

    •The <char> type:
    V = {NUL, ..., '0', …, '9', …, 'A', ..., 'Z', ..., ‘a', ..., 'z', DEL}
    O = {<<, >>, =, ++, --, isupper(), islower(), toupper(), … }

    •The <string> type:
    V = {"", "A", "B", "C", ..., "AA", "AB", "AC", ..., "AAA", ...}
    O = {<<, >>, +, +=, [], find(), substr(), … }

    [Main point]: Types have data and operations you can perform on that type
}

Fundamental Types:{

    [Better on slides]
    Name          V    C++   Ada   Smalltalk Lisp
    <bool> false, true bool boolean Boolean boole
    <char> the set of chars char character Character character
    <int> the integers int integer Integer integer
    <real> the reals double float Float real

    Given these, new types can be created via <type constructors>.

    Each constructor has 3 components: 
    − The syntax used to denote that constructor;
    − The set of elements produced by that constructor; and 
    − The operations associated with that constructor. 
}

Set Constructor I: <Product>:{
    The product constructor is the basis for <A x B>. [A cross B]
    
    -A×B consists of all ordered pairs (a, b): a ∈ A, b ∈ B.
    -A×B×C consists of all ordered triples (a, b, c): a ∈ A, b ∈ B , c ∈ C.
    -A×B× … ×N consists of all ordered n-tuples (a, b, …, n): a ∈ A, b ∈ B , …, n ∈ N.

    Example: the set <bool x char> has 256 elements:
    { …, (true, 'A'), (false, 'A'), (true, 'B'), (false, 'B'), …, }.

    − Operations associated with product are the <projection> operations:
     first, applied to an n-tuple (s1, s2, …, sn) returns <S1>.
     second, applied to an n-tuple (s1, s2, …, sn) returns <S2>.
     nth, applied to an n-tuple (s1, s2, …, sn) returns <Sn>.
}

Product Example: C++ structs:{
    [Look at slides for graphic]
    Formally, a student consists of int x real x char.

    Formally, a particular Student:
    aStudent.id = 12345;
    aStudent.gpa = 3.75;
    aStudent.gender = 'F';

    [Product is a meta language description, struct is just the C family realization of that primitive]

    is the 3-tuple: <(12345, 3.75, 'F')>.

    The C++ <"dot operator"> is a projection operation:
        cout << aStudent.id // extract id
            << aStudent.gpa // extract gpa
            << aStudent.gender // extract gender
            << endl;
    [How the first, second, nth is implemented in C++]
}

Set Constructor II: <Function>:{
    The function constructor is the basis for <subprograms>.

    − The set of all functions from a set A to a set B is denoted <(A) -> B>.  [A maps to B]
    − A particular function f mapping A to B is denoted <f(A) -> B>.  [Think prototypes in C++]

    Examples:
    − The set (char) → bool contains all functions that map char values into
    bool values, some C examples of which include: 
    isupper('A') -> true        islower('A') -> false
    isalpha('A') -> true        isdigit('A') -> false
    isa1num('A') -> true        isspace('A') -> false

    − The set (char) → char contains all functions that map char values into
    char values, some C examples of which include: 
    tolower('A') -> 'a'     toupper('a') -> 'A'
}

Function and Product:{[combining things]
    What does this set contain? (int × int) → int
    - All functions that map paris of integers into an integer
    [+,-,*,/]
    <
        +((2,3)) -> 5       -((2,3)) -> -1
        *((2,3)) -> 6       /((2,3)) -> 0
    >

    Suppose we define an
    aggregate named IntPair: [see slides]

    add() is a member of the set: <(int x int) -> int>
    − The function constructor let us create <new operations for a type>. 
    [Can create new types beyond primitives and expand the language using this]
}

Function Arity:{
    Product serves to denote an aggregate or an argument-list.
    What does this set contain? (int × int) → bool

    -All functions that map <pairs of integers into a boolean>
    <[==, !=, <, >, <=, >=]>

    Definition: 
    The number of operands an operation requires is its <arity>.
    − Operations with 1 operand are <unary> operations, with arity-1
    − Operations with 2 operands are <binary> operations, with arity-2.
    − Operations with 3 operand are <ternary> operations, with arity-3.
    - ...
}

Example Ternary Operaiton:{
    [See expression stuff on slides!]
    The C/C++ conditional expression is a ternary operation,
    which in this case is a member of the set:
    <?:(bool x int x int) -> int>
    
    [Board ex.
    cout << "There" << is-vs-are << numItems << "item" << "s?"
    cout << "there" << (numItems ==1)? "is" : "are"
    << numItems
    << "item"
    << (numItems == 1)? "" : "s"
    ]

}


Operator Positioning:{
    Operators are also categorized by their
    position relative to their operands:
    − <Infix> operators appear between their operands:1 + 2 
    − <Prefix> operators appear before their operands: + 1 2 
    − <Postfix> operators appear after their operands: 1 2 + 
    <* + 2 3 - 4 2 ≡ (2+3) * (4-2) ≡ - 2 3 + 4 2 - *>

    Prefix, infix, and postfix notation are different conventions
    for the same thing; a language may choose any of them:
    
    [Look at slides, this will help with table completion]
    x<y <binary, infix>     (<xy) <binary, prefix>
    ++x <unary, prefix>     (inc x) <unary, prefix>
    11+12 <binary, infix>   (+ 11 12) <unary, prefix>
    !flag <unary, prefix>   (not flag) <unary, prefix>
    cout << x <binary, infix>   (princ x str) <binary, prefix>
    x++ <unary, postfix>    None
}

Set Constructor III: Kleene Closure:{
    Kleene Closure is the basis for representing <sequences>. 
    − The Kleene Closure of a set A is denoted <A*>.
    − The Kleene Closure of a set is the set of all tuples that can be formed using elements of that set.

    Example: The Kleene Closure of bool -- bool* -- is the infinite set:
    { (), (false), (true), (false, false), (false, true), (true, false), (true, true), (false, false false)...}

    − For a tuple t ∈ A*, the operations include
null(A*) → bool 
    null(()) → <true> 
    null((false)) → <false> 
    null((true)) → <false> 
    first((true, false)) → <true> 
first(A*) → A    
    first((false, true)) → <false> 
rest(A*) → A*
    rest((true, true, false)) → <(true, false)> 
    rest((false, true, true)) → <(true, true)> [beheaded, all of the sequence except the first thing] 

}

Kleene Closure Examples:{
    If char is the set of ASCII characters, what is char* ?
    − The infinite set of <all tuples formed from ASCII characters>. (AKA the set of all <strings>).

    The C/C++ notation "Hello" is just the syntax for ('H', 'e', 'l', 'l', 'o',)

    Thus, int* denotes a sequence (array, list, …) of <integers>;
        int intStaticArray[32];
        int * intDynamicArray = new int[n],
        vector<int> intVec;
        list<int> intList;
        [The key is that these things are ordered]
    real* denotes a sequence (array, list, …) of <reals>;
        and so on.
}

Sequence Operations:{
    [All on slides]

    In Lisp:
    - First is called <car>
    - Rest is called <cdr>
}

Practice Using Constructors:{
    Formal description for the logical and operation:
    <Takes 2 operands
    - Uses bool, bool operands
    - Produces a bool
    - Therefore is a member of (bool x bool) -> bool>

    The C++/STL substring operation(str.substr(i,n))
    <Takes 3 parameters (this, i, n)
    - Types are string (char*), int, int
    - Produces a string (char*)
    - Therefore is a member of (string x int x int) -> string>

    For you: The logical negation operation (!):
    - Member of (bool) -> bool

    This [on slides] C++ record:
    - Represent agregate types with a product (*)
    - [student can be though of as an element of this set] 
    - Answer: (int x string x bool x real)

    An accessor method:
    - Member of (Student) -> int

    How does this affect our Student description?:
    - Student (element of) int x ((Student -> int) x int x string x bool x real)

    A "complete" class:
    [CLASS]
    Student (elemnt of) 
        [OPERATIONS]
        () -> Student
        x (int x string x bool x real) -> Student
        x (Student) -> int
        x (Student) -> string
        x (Student) -> bool
        x (Student) -> real
        x (Student x istream&) -> (null)
        x (Student x ostream&) -> (null)
        [DATA]
        x (int x string x bool x real) 
}

Sumary:{
    A type conists of <data> and <operations>

    The set constructors:
    - <product>,
    - <function>,
    - <Kleene closure>
    provide a formal way to represent types:

    → Use the product and Kleene closure to represent the <data>;
    → Use the function constructor to represent the <operations> on the type.

    [The key is that these things are language independant, can compare
    the languages capabilities in a way that's independant of either of them;
    mathematical "syntax" that sits above any particular language]
}

